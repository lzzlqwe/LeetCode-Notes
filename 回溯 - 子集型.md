# 代表性题目

## [1.电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
思路：经典dfs题目。用char[]替代String可以显著提升时间。     
代码：
```
class Solution {
    Map<Character, String> mp = new HashMap<>();
    List<String> ans = new  ArrayList<>();

    public List<String> letterCombinations(String digits) {
        mp.put('2', "abc");
        mp.put('3', "def");
        mp.put('4', "ghi");
        mp.put('5', "jkl");
        mp.put('6', "mno");
        mp.put('7', "pqrs");
        mp.put('8', "tuv");
        mp.put('9', "wxyz");
        char[] str = new char[digits.length()];
        if(!digits.equals("")) dfs(str, 0, digits);
        return ans;
    }

    public void dfs(char[] str, int i, String digits)
    {
        if(i == digits.length())
        {
            ans.add(new String(str));
            return;
        }
        char[] layer = mp.get(digits.charAt(i)).toCharArray();
        for(char c : layer)
        {
            str[i] = c;
            dfs(str, i + 1, digits);
        }
    }
}
```

## [2.子集](https://leetcode.cn/problems/subsets/description/)
思路：子集型，每个元素可选可不选，需要回溯。     
代码：
```
class Solution {
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(new ArrayList<>(), 0, nums);
        return ans;
    }

    public void dfs(List<Integer> arr, int i, int[] nums)
    {
        if(i == nums.length)
        {
            ans.add(new ArrayList<>(arr)); //记得复制，不然得到错误答案！！
            return;
        }
        //不选第i个元素
        dfs(arr, i+1, nums);
        //选第i个元素
        arr.add(nums[i]);
        dfs(arr, i+1, nums);
        arr.remove(arr.size()-1); //回溯
    }
}
```

## [3.分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/)
思路：假设每对相邻字符之间有个逗号，那么就看每个逗号是选还是不选。     
代码：
```
class Solution {
    List<List<String>> ans = new ArrayList<>();

    public List<List<String>> partition(String s) {
        dfs(new ArrayList<>(), 0, 0, s);
        return ans;
    }

    void dfs(List<String> path, int start, int i, String s)
    {
        if(i == s.length() - 1) //最后一个索引一定得切割
        {
            String fstr = s.substring(start, i+1);
            if(huiwen(fstr)) 
            {
                path.add(fstr);
                ans.add(new ArrayList<>(path)); //记得拷贝
                path.remove(path.size()-1);//回溯
            }
            return;
        }
        //索引i切割（子串包含索引i字符）(也可以看作相邻字符间的逗号)
        String str = s.substring(start, i+1);
        if(huiwen(str)) //若不符合，则剪枝
        {
            path.add(str);
            dfs(path, i+1, i+1, s);
            path.remove(path.size()-1);//回溯
        }
        //索引i不切割
        dfs(path, start, i+1, s);
    }

    //判断子串是否为都为回文串
    public boolean huiwen(String s)
    {
        char[] subs = s.toCharArray();
        int l = 0;
        int r = subs.length - 1;
        while(l <= r)
        {
            if(subs[l] != subs[r])
                return false;
            l++;
            r--;
        }
        return true;
    }
}
```
