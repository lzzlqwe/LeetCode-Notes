# 代表性题目

### 模板代码
```
int start = 0;
int end = 0;
while(end < n){ //外层循环扩展右边界，内层循环扩展左边界
    xxx;  //当前考虑的元素
    while(start <= end && 条件){
        xxx
        start++; //扩展左边界
    }
    end++; //扩展右边界
}
```

## [1.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
思路：定义两个指针，分别代表滑动窗口的左右指针，初始值都为0。外层while循环，右指针从左到右遍历，内层循环则根据控制条件，左指针向右便遍历。  
代码：
```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0;
        int r = 0;
        int minl = nums.length + 1;
        int sum = 0;
        while(r < nums.length)
        {
            sum += nums[r];
            while(sum >= target)
            {
                minl = Math.min(minl, r-l+1);
                sum -= nums[l];
                l++;
            }
            r++;
        }
        if(minl > nums.length)
            return 0;
        else
            return minl;
    }
}
```

## [2.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
思路：套用滑动窗口模板  
代码：
```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> hash = new HashSet<Character>();
        int l = 0;
        int r = 0;
        int maxl = 0;
        while(r < s.length())
        {
            char c = s.charAt(r);
            while(l <= r && hash.contains(c))
            {
                hash.remove(s.charAt(l));
                l++;
            }
            hash.add(c);
            maxl = Math.max(maxl, r-l+1);
            r++;
        }
        return maxl;
    }
}
```
