# 代表性题目

### 模板代码
```
int start = 0;
int end = 0;
while(end < n){ //外层循环扩展右边界，内层循环扩展左边界
    xxx;  //当前考虑的元素
    while(start <= end && 条件){
        xxx
        start++; //扩展左边界
    }
    end++; //扩展右边界
}
```

### 注意事项
1. 整形无穷大用Integer.MAX_VALUE，类似的无穷小为Integer.MIN_VALUE  
2. 采用集合Set<Character> set = new HashSet<Character>()来记录是否出现过，add()添加，remove()去除，contains()用于判断是否存在
3. 采用Map<xx, xx> map = new HashMap<xx, xx>()来记录出现过的次数。map.merge(nums[end], 1, Integer::sum)这行代码的完整含义是：在map中查找键为nums[end]的元素。如果找到了，就将该键对应的值与1相加。如果没有找到，就将键nums[end]和值1添加到map中。同理用-1代替1可用于减法。get()用于获取指定 key 对应对 value。

## [1.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
思路：定义两个指针，分别代表滑动窗口的左右指针，初始值都为0。外层while循环，右指针从左到右遍历，内层循环则根据控制条件，左指针向右便遍历。  
代码：
```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0;
        int r = 0;
        int minl = nums.length + 1;
        int sum = 0;
        while(r < nums.length)
        {
            sum += nums[r];
            while(sum >= target)
            {
                minl = Math.min(minl, r-l+1);
                sum -= nums[l];
                l++;
            }
            r++;
        }
        if(minl > nums.length)
            return 0;
        else
            return minl;
    }
}
```

## [2.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
思路：套用滑动窗口模板  
代码：
```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> hash = new HashSet<Character>();
        int l = 0;
        int r = 0;
        int maxl = 0;
        while(r < s.length())
        {
            char c = s.charAt(r);
            while(l <= r && hash.contains(c))
            {
                hash.remove(s.charAt(l));
                l++;
            }
            hash.add(c);
            maxl = Math.max(maxl, r-l+1);
            r++;
        }
        return maxl;
    }
}
```

## [3.乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
思路：套用滑动窗口模板  
代码：
```
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int l = 0;
        int r = 0;
        int mul = 1;
        int ans = 0;
        while(r < nums.length)
        {
            mul *= nums[r];
            while(l <= r && mul >= k)
            {
                mul /= nums[l];
                l++;
            }
            ans += (r - l  +1);
            r++;
        }
        return ans;
    }
}
```
