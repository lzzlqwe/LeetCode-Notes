# 代表性题目

### 二分查找模板代码
```
// lowerBound 返回最小的满足 nums[i] >= target 的 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

// 闭区间写法
// 区间的定义: 表示我们需要知道这个区间内的元素和target的关系 ！！！！！！
private int lowerBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        int mid = left + (right - left) / 2; //防止加法溢出 ！！！！！！
        if (nums[mid] < target) {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        } else {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        }
    }
    return left;
}
```


### 注意事项
1. 上述模板代码 lowerBound 返回的是最小的满足 nums[i] >= target 的 i（属于 >= 的情况）
2. 对于 >, <=, < 的其他三种情况，可以转换一下。比如 > target 可以转换为 >= target，以此类推。

### 二分答案模板代码
```
// 闭区间写法
private int lowerBound(int[] nums, int target) {
    int left = x, right = y; // x到y为可能的答案
    while (left <= right) { 
        int mid = left + (right - left) / 2; //防止加法溢出 ！！！！！！
        if (!check(mid)) {  //检查条件，若不满足
            left = mid + 1; 
        } else {  //条件满足
            right = mid - 1; 
        }
    }
    return left;  //返回满足条件的最小值
}
```

## [1.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
思路：属于 >= 和 > 的情况  
代码：
```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int ans1 = lower_bound(nums, target);
        if(ans1 == nums.length || nums[ans1] != target)
            return new int[]{-1, -1};
        
        int ans2 = lower_bound(nums, target + 1) - 1;
        return new int[]{ans1, ans2};
    }

    public int lower_bound(int[] nums, int target)
    {
        int l = 0;
        int r = nums.length - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [2.正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/)
思路：分别统计正整数和负整数的个数  
代码：
```
class Solution {
    public int maximumCount(int[] nums) {
        int ans1 = lower_bound(nums, 0) - 0; //负整数个数
        int ans2 = nums.length - lower_bound(nums, 1); //正整数个数
        return Math.max(ans1, ans2);
    }

    public int lower_bound(int[] nums, int target)
    {
        int l = 0;
        int r = nums.length - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [3.统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/description/)
思路：自定义初始区间的二分查找 + [left, right)区间的元素个数 = right-left  
代码：
```
class Solution {
    public long countFairPairs(int[] nums, int lower, int upper) {
        Arrays.sort(nums);
        int n = nums.length;
        long ans = 0;
        for(int i = 0; i < nums.length; i++)
        {
            long target1 = lower - nums[i];
            int ans1 = lower_bound(nums, target1, i+1, n-1);
            long target2 = upper - nums[i] + 1;
            int ans2 = lower_bound(nums, target2, i+1, n-1);
            ans += ans2 - ans1;
        }
        return ans;
    }

    public int lower_bound(int[] nums, long target, int left, int right)
    {
        int l = left;
        int r = right;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [4.区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/description/)
思路：用一个HashMap存放各个元素所出现的所有下标，下标是排好序的，可以直接二分查找。包含HashMap做题所需常用的操作，不容易忘记！！！  
代码：
```
class RangeFreqQuery {

    private Map<Integer, List<Integer>> mp = new HashMap<>();

    public RangeFreqQuery(int[] arr) {
        for(int i = 0; i < arr.length; i++)
        {
            if(mp.get(arr[i]) == null)
                mp.put(arr[i], new ArrayList<>());
            mp.get(arr[i]).add(i);
        }
    }
    
    public int query(int left, int right, int value) {
        if(mp.get(value) == null)
            return 0;
        int ans1 = lower_bound(mp.get(value), left);
        int ans2 = lower_bound(mp.get(value), right + 1);
        return ans2 - ans1;
    }

    public int lower_bound(List<Integer> nums, int target)
    {
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r)
        {
            int mid = l + (r-l) / 2;
            if(nums.get(mid) < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }   
}
```

## [5.H 指数 II](https://leetcode.cn/problems/h-index-ii/description/)
思路：最后的答案肯定是[ans:]区间内的论文，所以思路就是去寻找这个ans。  
代码：
```
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int left = 0;
        int right = n - 1;
        while(left <= right)
        {
            int mid = left + (right - left) / 2;
            if(citations[mid] < n - mid)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return n - left;
    }
}
```

## [6.爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/description/)
思路：属于二分答案题目。  
代码：
```
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        Arrays.sort(piles);
        int left = 1;
        int right = piles[piles.length - 1];
        while(left <= right)
        {
            int mid = left + (right - left) / 2;
            if(!check(piles, mid, h)) //不满足条件
                left = mid + 1;
            else       //满足条件
                right = mid - 1;
        }
        return left;
    }

    public boolean check(int[] nums, int eat, int h)
    {
        int ans = 0;
        for(int i = 0; i < nums.length; i++)
        {
            ans += Math.ceil(1.0 * nums[i] / eat);
        }
        if(ans > h)
            return false;
        else
            return true;
    }
}
```
