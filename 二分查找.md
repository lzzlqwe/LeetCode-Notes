# 代表性题目

### 模板代码
```
// lowerBound 返回最小的满足 nums[i] >= target 的 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

// 闭区间写法
// 区间的定义: 表示我们需要知道这个区间内的元素和target的关系 ！！！！！！
private int lowerBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        int mid = left + (right - left) / 2; //防止加法溢出 ！！！！！！
        if (nums[mid] < target) {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        } else {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        }
    }
    return left;
}
```


### 注意事项
1. 上述模板代码 lowerBound 返回的是最小的满足 nums[i] >= target 的 i（属于 >= 的情况）
2. 对于 >, <=, < 的其他三种情况，可以转换一下。比如 > target 可以转换为 >= target，以此类推。

## [1.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
思路：属于 >= 和 > 的情况  
代码：
```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int ans1 = lower_bound(nums, target);
        if(ans1 == nums.length || nums[ans1] != target)
            return new int[]{-1, -1};
        
        int ans2 = lower_bound(nums, target + 1) - 1;
        return new int[]{ans1, ans2};
    }

    public int lower_bound(int[] nums, int target)
    {
        int l = 0;
        int r = nums.length - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [2.正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/)
思路：分别统计正整数和负整数的个数  
代码：
```
class Solution {
    public int maximumCount(int[] nums) {
        int ans1 = lower_bound(nums, 0) - 0; //负整数个数
        int ans2 = nums.length - lower_bound(nums, 1); //正整数个数
        return Math.max(ans1, ans2);
    }

    public int lower_bound(int[] nums, int target)
    {
        int l = 0;
        int r = nums.length - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums[mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```
