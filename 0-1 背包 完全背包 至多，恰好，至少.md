# 代表性题目

### 0-1背包问题模板代码（[原题](https://www.marscode.cn/practice/vk3kkpde4ndp9k?problem_id=7424436653369884716)）
```
public static int solution(int n, int[] weights, int[] values, int m) {
    // 二维数组
    int[][] dp = new int[n+1][m+1];//dp[i][j]表示前i件物品在背包承重j的状态下能放进背包里面的物品的最大总价值
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            if(weights[i-1] > j)  //当前背包放不下第i件物品
                dp[i][j] = dp[i-1][j];
            else
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1]); //不选或者选
        }
    }

    //一维数组（参考https://www.acwing.com/solution/content/1374/）
    int[] dp = new int[m+1]; //定义：n件物品，背包容量j下的最优解
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= weights[i-1]; j--) //因为当前结果由max(左上角，正上方)决定，逆序可以保证不会左上角的值不被污染。
            dp[j] = Math.max(dp[j], dp[j-weights[i-1]]+values[i-1]); // 0-1背包是逆序，完全背包是正序
    return dp[m];
}
```


### 完全背包问题模板代码（[题解以及思路](https://www.acwing.com/solution/content/5345/)）
```
状态转移方程为：
f[i][j]=max(f[i,j-v]+w , f[i-1][j])

//一维数组模板
for(int i = 1; i <= n; i++)
    for(int j = weights[i-1]; j <= m; j++) // 0-1背包是逆序，完全背包是正序
        dp[j] = Math.max(dp[j], dp[j-weights[i-1]]+values[i-1]); 
```

## [1.目标和](https://leetcode.cn/problems/target-sum/description/)
思路： 详见代码注释（两种做法）
代码：
```
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        //转换问题
        int sum = 0;
        for(int x : nums) sum += x; //求所有数的和(恒为正数)
        //假设前面为'+'的数和为p，则'-'的数的和为-(sum-p)
        //所以 p-(sum-p)=target，得到p=(target+sum)/2
        //问题转换为：从这些数取某些值，使得其刚好等于(target+sum)/2
        int s = target + sum;
        //特殊情况判断
        if(s < 0 || s % 2 == 1)
            return 0;
        //通常情况（二维数组）
        // int new_target = s / 2;
        // int[][] dp = new int[n+1][new_target+1];//考虑前i个数，和为j的方案数
        // dp[0][0] = 1; //初始化（0个数和为0的方案数为1）
        // for(int i = 1; i <= n; i++)
        // {
        //     for(int j = 0; j <= new_target; j++) //要考虑和为0
        //     {
        //         if(nums[i-1] > j)
        //             dp[i][j] = dp[i-1][j];
        //         else
        //             dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
        //     }
        // }
        // return dp[n][new_target];
        //通常情况（一维数组）
        int new_target = s / 2;
        int[] dp = new int[new_target+1];
        dp[0] = 1; //初始化
        for(int i = 1; i <= n; i++)
        {
            for(int j = new_target; j >= nums[i-1]; j--) 
            {
                dp[j] = dp[j] + dp[j-nums[i-1]];
            }
        }
        return dp[new_target];
    }
}
```

## [2.零钱兑换](https://leetcode.cn/problems/coin-change/description/)
思路：状态转移方程：f[i][j] = min(f[i-1][j], f[i][j-val]+1)   
代码：
```
class Solution {
    public int coinChange(int[] coins, int amount) {
        //状态转移方程：f[i][j] = min(f[i-1][j], f[i][j-val]+1)
        int n = coins.length;
        int[] dp = new int[amount+1];
        int MAX = amount + 1;//最大硬币个数
        Arrays.fill(dp, MAX);//初始化
        dp[0] = 0;//金额为0需要0个硬币
        for(int i = 1; i <= n; i++)
            for(int j = coins[i-1]; j <= amount; j++)
                dp[j] = Math.min(dp[j], dp[j-coins[i-1]]+1);
        return dp[amount] > amount? -1 : dp[amount];
    }
}
```
