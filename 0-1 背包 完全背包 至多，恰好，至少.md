# 代表性题目

### 0-1背包问题模板代码（[原题](https://www.marscode.cn/practice/vk3kkpde4ndp9k?problem_id=7424436653369884716)）
```
public static int solution(int n, int[] weights, int[] values, int m) {
    // // 二维数组
    // int[][] dp = new int[n+1][m+1];//dp[i][j]表示前i件物品在背包承重j的状态下能放进背包里面的物品的最大总价值
    // for(int i = 1; i <= n; i++)
    // {
    //     for(int j = 1; j <= m; j++)
    //     {
    //         if(weights[i-1] > j)  //当前背包放不下第i件物品
    //             dp[i][j] = dp[i-1][j];
    //         else
    //             dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1]); //不选或者选
    //     }
    // }

    //一维数组（参考https://www.acwing.com/solution/content/1374/）
    int[] dp = new int[m+1]; //定义：n件物品，背包容量j下的最优解
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= weights[i-1]; j--) //因为当前结果由max(左上角，正上方)决定，逆序可以保证不会左上角的值不被污染。
            dp[j] = Math.max(dp[j], dp[j-weights[i-1]]+values[i-1]); // 0-1背包是逆序，完全背包是正序
    return dp[m];
}
```


### 注意事项
1. 

### 完全背包问题模板代码
```

```

## [1.]()
思路： 
代码：
```
```
