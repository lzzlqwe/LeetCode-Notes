# 代表性题目

## [1.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
思路：反转链表经典模板。使用两个指针pre和cur，反转结束后，从原来的链表上看，pre指向最末尾节点，cur指向后续的下一个节点，为null。  
代码：
```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while(cur != null)
        {
            ListNode nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
}
```

## [2.反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)
思路：在链表前面加一个空节点，以解决特殊情况！！！  
代码：
```
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        //在链表开头添加一个空节点，下标为0
        ListNode top = new ListNode(0, head);
        ListNode cur = top;
        ListNode pre = null;
        int curId = 0;  //表示cur指针当前的下标
        while(curId != left) //找到cur指针指向left元素
        {
            pre = cur;
            cur = cur.next;
            curId++;
        }
        ListNode leftPre = pre; //记录left元素的上一元素 leftPre.next指向left元素
        pre = null; 
        while(curId <= right) //反转[left,right]
        {
            ListNode nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
            curId++;
        }  //[left,right]反转结束后，pre指向right元素，cur指向right下一元素
        //将[left,right]重新拼接到原始链表。
        leftPre.next.next = cur;
        leftPre.next = pre;
        return top.next;
    }
}
```
