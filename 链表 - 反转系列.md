# 代表性题目

## [1.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
思路：反转链表经典模板。使用两个指针pre和cur，反转结束后，从原来的链表上看，pre指向最末尾节点，cur指向后续的下一个节点，为null。  
代码：
```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while(cur != null)
        {
            ListNode nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
}
```

## [2.反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)
思路：在链表前面加一个空节点，以解决特殊情况！！！  
代码：
```
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        //在链表开头添加一个空节点，下标为0
        ListNode top = new ListNode(0, head);
        ListNode cur = top;
        ListNode pre = null;
        int curId = 0;  //表示cur指针当前的下标
        while(curId != left) //找到cur指针指向left元素
        {
            pre = cur;
            cur = cur.next;
            curId++;
        }
        ListNode leftPre = pre; //记录left元素的上一元素 leftPre.next指向left元素
        pre = null; 
        while(curId <= right) //反转[left,right]
        {
            ListNode nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
            curId++;
        }  //[left,right]反转结束后，pre指向right元素，cur指向right下一元素
        //将[left,right]重新拼接到原始链表。
        leftPre.next.next = cur;
        leftPre.next = pre;
        return top.next;
    }
}
```

## [3,K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)
思路：在链表前面加一个空节点，思路和上一题类似。
代码：
```
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode cur = head;
        int n = 0;
        while(cur != null) //统计一共有多少个节点
        {
            n++;
            cur = cur.next;
        }
        //链表头添加一个空节点，下标为0。
        ListNode top = new ListNode(0, head); 
        cur = head;
        ListNode pre = null;
        ListNode leftPre = top;
        for(int i = 0; i < n / k; i++) //总共需要反转n/k段
        {
            for(int j = 0; j < k; j++) //每一段反转k个节点
            {
                ListNode nxt = cur.next;
                cur.next = pre;
                pre = cur;
                cur = nxt;
            }
            leftPre.next.next = cur;
            ListNode tmp = leftPre.next;
            leftPre.next = pre;
            leftPre = tmp;
        }
        return top.next;
    }
}
```
