# 代表性题目

## [1.打家劫舍](https://leetcode.cn/problems/house-robber/description/)

### 方法一（递推）
思路：选或者不选。前i号房屋的最高金额 = max(选：前i-2号房屋的最高金额+i号房屋的金额，不选：前i-1号房屋的最高金额)，得到dp递推公式。   
代码：
```
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length+1]; //表示前i号房屋的最高金额
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i <= nums.length; i++)
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]); //不选和选
        return dp[nums.length];
    }
}
```

### 方法二（递推+滚动数组优化空间）
思路：其实就是用三个变量，一个保存上上个元素，一个保存上个元素，最后一个保存当前元素。


## [2.爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
思路：台阶i方法数=台阶i-1方法数（再爬一个台阶）+台阶i-2方法数（再爬二个台阶）     
代码：
```
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1]; //dp[i]表示当前i阶楼梯有多少种方法
        dp[0] = 1; //初始化
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
            dp[i] = dp[i-1] + dp[i-2]; //台阶i方法数=台阶i-1方法数（再爬一个台阶）+台阶i-2方法数（再爬二个台阶）
        return dp[n];
    }
}
```

## [3.使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)
思路：到达台阶i的最低消费=min(到达台阶i-1的最低消费（再爬一个台阶）+第i-1个台阶向上爬需要支付的费用，到达台阶i-2的最低消费（再爬二个台阶）+第i-2个台阶向上爬需要支付的费用)     
代码：
```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n+1];
        dp[0] = dp[1] = 0;
        for(int i = 2; i <= n; i++)
            dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        return dp[n];
    }
}
```

## [4.组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)
思路：思想和[2.爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)一样。可以爬的台阶数从1或者2变为整个nums数组中的数。     
代码：
```
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1; i <= target; i++)
        {
            for(int x: nums)
            {
                if(i - x >= 0)
                    dp[i] += dp[i-x];
            }
        }
        return dp[target];
    }
}
```

## [5.统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/description/)
思路：dp[i]表示长度为i有几个好字符串，默认值为0。dp[i] = dp[i-zero] + dp[i-one]。    
代码：
```
class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        final int MOD = (int)(1e9 + 7);
        int[] dp = new int[high+1];  //dp[i]表示长度为i有几个好字符串，默认值为0
        dp[0] = 1; //初始化
        for(int i = 1; i <= high; i++)
        {
            if(i - zero >= 0)
                dp[i] = (dp[i] + dp[i-zero]) % MOD;
            if(i - one >= 0)
                dp[i] = (dp[i] + dp[i-one]) % MOD;
        }
        int ans = 0;
        for(int i = low; i <= high; i++)
            ans = (ans + dp[i]) % MOD; //取模防止溢出
        return ans;
    }
}
```
