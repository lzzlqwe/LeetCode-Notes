# 代表性题目

## [1.打家劫舍](https://leetcode.cn/problems/house-robber/description/)

### 方法一（递推）
思路：选或者不选。前i号房屋的最高金额 = max(选：前i-2号房屋的最高金额+i号房屋的金额，不选：前i-1号房屋的最高金额)，得到dp递推公式。   
代码：
```
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length+1]; //表示前i号房屋的最高金额
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i <= nums.length; i++)
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]); //不选和选
        return dp[nums.length];
    }
}
```

### 方法二（递推+滚动数组优化空间）
思路：其实就是用三个变量，一个保存上上个元素，一个保存上个元素，最后一个保存当前元素。


## [2.爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
思路：台阶i方法数=台阶i-1方法数（再爬一个台阶）+台阶i-2方法数（再爬二个台阶）     
代码：
```
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1]; //dp[i]表示当前i阶楼梯有多少种方法
        dp[0] = 1; //初始化
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
            dp[i] = dp[i-1] + dp[i-2]; //台阶i方法数=台阶i-1方法数（再爬一个台阶）+台阶i-2方法数（再爬二个台阶）
        return dp[n];
    }
}
```
