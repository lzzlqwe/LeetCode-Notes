# 代表性题目

## [1.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

### 方法一（自底向上）
思路：经典题目。整个树的深度 = max(左子树深度，右子树深度) + 1    
代码：
```
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### 方法二（自顶向下）
思路：使用dfs经典模板。      
代码：
```
class Solution {
    public int maxDep = 0; //全局变量

    public int maxDepth(TreeNode root) {
        dfs(root, 1);
        return maxDep;
    }

    public void dfs(TreeNode root, int depth)
    {
        if(root == null) //结束条件
            return;
        maxDep = Math.max(depth, maxDep);
        //依次遍历当前节点的子节点
        dfs(root.left, depth + 1);
        dfs(root.right, depth + 1);
    }
}
```

### 注意事项
上述两种方法都属于dfs模板。方法一是在“归”的时候返回一个值进行处理，所以自底向上；而方法二则是在“递”的时候就处理，不需要返回值，所以自顶向下。dfs模板代码（只针对树或者二叉树）如下：  
```
dfs(TreeNode root, int depth) //depth表示当前节点的深度
{
    if(结束条件)
        return;
    //自顶向下处理代码
    xxxxxxxxxx
    //依次遍历当前节点的子节点，多个子节点一般使用for循环，二叉树就没必要。
    for循环
    {
        dfs(子节点i, depth + 1); //深度记得加1
        //自底向上处理代码
        xxxxxxxxxx
    }
}
```

## [2.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

### 方法一（自底向上）
思路：和上一题类似。      
代码：
```
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null)
            return 0;
        if(root.left == null && root.right != null)
            return minDepth(root.right) + 1;
        else if(root.left != null && root.right == null)
            return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
```

### 方法二（自顶向下）
思路：和上一题类似。      
代码：
```
class Solution {
    public int mindep = 100001;

    public int minDepth(TreeNode root) {
        if(root == null)
            return 0;
        dfs(root, 1);
        return mindep;
    }

    public void dfs(TreeNode root, int depth)
    {
        if(root == null)
            return;
        if(root.left == null && root.right == null) //叶子节点
            mindep = Math.min(mindep, depth);
        dfs(root.left, depth+1);
        dfs(root.right, depth+1);
    }
}
```
