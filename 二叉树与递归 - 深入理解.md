# 代表性题目

## [1.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

### 方法一（自底向上）
思路：经典题目。整个树的深度 = max(左子树深度，右子树深度) + 1    
代码：
```
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### 方法二（自顶向下）
思路：dfs经典模板。      
代码：
```
class Solution {
    public int maxDep = 0; //全局变量

    public int maxDepth(TreeNode root) {
        dfs(root, 1);
        return maxDep;
    }

    public void dfs(TreeNode root, int depth)
    {
        if(root == null) //结束条件
            return;
        maxDep = Math.max(depth, maxDep);
        //依次遍历当前节点的子节点
        dfs(root.left, depth + 1);
        dfs(root.right, depth + 1);
    }
}
```

### 注意事项
上述两种方法都属于dfs模板。方法一是在“归”的时候返回一个值进行处理，所以自底向上；而方法二则是在“递”的时候就处理，不需要返回值，所以自顶向下。dfs模板代码（只针对树或者二叉树）如下：  
```
public void dfs(TreeNode root, int depth) //depth表示当前深度
{
    if(root == null) //结束条件
        return;
    //处理代码（比如处理当前depth）
    xxxxxxxxxx
    //依次遍历当前节点的子节点，多个子节点一般使用for循环，二叉树就没必要。
    dfs(子节点1, depth + 1); //深度记得加1
    dfs(子节点2, depth + 1);
}
```
