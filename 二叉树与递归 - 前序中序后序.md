# 代表性题目

## [1.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

### 方法一（前序遍历）
思路：每次维护一个开区间，判断当前节点值是否在该区间内。   
代码：
```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return preDfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean preDfs(TreeNode node, long left, long right) //开区间(left, right)
    {
        if(node == null)
            return true;
        return left < node.val && node.val < right && 
                preDfs(node.left, left, node.val) && 
                preDfs(node.right, node.val, right);
    }
}
```

### 方法二（中序遍历）
思路：如果树是一个二叉搜索树,则中序遍历得到的序列是递增的。可以维护一个值pre,用于记录上一个节点的值.    
代码：
```
class Solution {
    public long pre = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        if(root == null)
            return true;
        if(!isValidBST(root.left) || root.val <= pre)
            return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}
```

### 方法三（后序遍历）
思路：每次返回左右子树的最大最小值区间,判断当前节点值是否符合条件.     
代码：
```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root)[0] != Long.MIN_VALUE;
    }

    public long[] dfs(TreeNode node) //返回该子树的最小值和最大值,闭区间
    {
        if(node == null)
            return new long[]{Long.MAX_VALUE, Long.MIN_VALUE};;
        long[] ltree = dfs(node.left);
        long[] rtree = dfs(node.right);
        if(node.val <= ltree[1] || node.val >= rtree[0])
            return new long[]{Long.MIN_VALUE, Long.MAX_VALUE};
        return new long[]{Math.min(ltree[0], node.val), 
            Math.max(rtree[1], node.val)}; //max和min只在叶子节点有用
    }
}
```


## [2.二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/description/)
思路：前序遍历 + 利用二叉搜索树性质剪枝。      
代码：
```
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null)
            return 0;
        if(root.val < low) 
            return rangeSumBST(root.right, low, high);
        if(root.val > high)
            return rangeSumBST(root.left, low, high);
        return root.val + rangeSumBST(root.left, low, high)
                 + rangeSumBST(root.right, low, high);
    }
}
```

## [3.二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/description/)
思路：中序遍历 + 二分查找。      
代码：
```
class Solution {
    public List<Integer> ls = new ArrayList<>();

    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {
        midDfs(root);
        List<List<Integer>> ans = new ArrayList<>();
        queries.forEach(q -> {
            int j = lower_bound(ls, q);
            int max1 = j == ls.size()? -1 : ls.get(j);
            int min1;
            if(j == ls.size() || ls.get(j) > q)
                j--;
            min1 = j < 0? - 1 : ls.get(j);
            ans.add(List.of(min1, max1));
        });
        return ans;
    }

    //中序遍历
    void midDfs(TreeNode node)
    {
        if(node == null)
            return;
        midDfs(node.left);
        ls.add(node.val);
        midDfs(node.right);
    }

    //二分查找
    int lower_bound(List<Integer> nums, int target)
    {
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums.get(mid) < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [4.二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)
思路：中序遍历，见代码注释。      
代码：
```
class Solution {
    public int n = 0;

    public int kthSmallest(TreeNode root, int k) {
        if(root == null)
            return -1;
        int l = kthSmallest(root.left, k); //查找左子树
        if(l != -1) return l;  //若已经找到则直接返回。
        n = n + 1;
        if(n == k) return root.val; //若当前节点满足则直接返回
        return kthSmallest(root.right, k); //答案在右子树
    }
}
```
