# 代表性题目

## 注意事项
1. 一般下层要用到的信息就是通过参数传递，上层要用到的信息则是通过返回值。
2. 如果答案需要遍历所有节点，则不能使用剪枝。反之如果提前知道答案，则可以使用剪枝提前返回。（第一题的前序遍历和中中序遍历其实都是用了剪枝，而后序遍历则因为一定得递归调用左右子树后才返回当前节点，所以不存在什么剪枝操作）。    

## [1.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

### 方法一（前序遍历）
思路：每次维护一个开区间，判断当前节点值是否在该区间内。   
代码：
```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return preDfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean preDfs(TreeNode node, long left, long right) //开区间(left, right)
    {
        if(node == null)
            return true;
        return left < node.val && node.val < right && 
                preDfs(node.left, left, node.val) && 
                preDfs(node.right, node.val, right);
    }
}
```

### 方法二（中序遍历）
思路：如果树是一个二叉搜索树,则中序遍历得到的序列是递增的。可以维护一个值pre,用于记录上一个节点的值.    
代码：
```
class Solution {
    public long pre = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        if(root == null)
            return true;
        if(!isValidBST(root.left) || root.val <= pre)
            return false;
        pre = root.val;
        return isValidBST(root.right);
    }
}
```

### 方法三（后序遍历）
思路：每次返回左右子树的最大最小值区间,判断当前节点值是否符合条件.     
代码：
```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root)[0] != Long.MIN_VALUE;
    }

    public long[] dfs(TreeNode node) //返回该子树的最小值和最大值,闭区间
    {
        if(node == null)
            return new long[]{Long.MAX_VALUE, Long.MIN_VALUE};;
        long[] ltree = dfs(node.left);
        long[] rtree = dfs(node.right);
        if(node.val <= ltree[1] || node.val >= rtree[0])
            return new long[]{Long.MIN_VALUE, Long.MAX_VALUE};
        return new long[]{Math.min(ltree[0], node.val), 
            Math.max(rtree[1], node.val)}; //max和min只在叶子节点有用
    }
}
```


## [2.二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/description/)
思路：前序遍历 + 利用二叉搜索树性质剪枝。      
代码：
```
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null)
            return 0;
        if(root.val < low) 
            return rangeSumBST(root.right, low, high);
        if(root.val > high)
            return rangeSumBST(root.left, low, high);
        return root.val + rangeSumBST(root.left, low, high)
                 + rangeSumBST(root.right, low, high);
    }
}
```

## [3.二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/description/)
思路：中序遍历 + 二分查找。      
代码：
```
class Solution {
    public List<Integer> ls = new ArrayList<>();

    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {
        midDfs(root);
        List<List<Integer>> ans = new ArrayList<>();
        queries.forEach(q -> {
            int j = lower_bound(ls, q);
            int max1 = j == ls.size()? -1 : ls.get(j);
            int min1;
            if(j == ls.size() || ls.get(j) > q)
                j--;
            min1 = j < 0? - 1 : ls.get(j);
            ans.add(List.of(min1, max1));
        });
        return ans;
    }

    //中序遍历
    void midDfs(TreeNode node)
    {
        if(node == null)
            return;
        midDfs(node.left);
        ls.add(node.val);
        midDfs(node.right);
    }

    //二分查找
    int lower_bound(List<Integer> nums, int target)
    {
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(nums.get(mid) < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        return l;
    }
}
```

## [4.二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/)
思路：中序遍历，见代码注释。      
代码：
```
class Solution {
    public int n = 0;

    public int kthSmallest(TreeNode root, int k) {
        if(root == null)
            return -1;
        int l = kthSmallest(root.left, k); //查找左子树
        if(l != -1) return l;  //若已经找到则直接返回。
        n = n + 1;
        if(n == k) return root.val; //若当前节点满足则直接返回
        return kthSmallest(root.right, k); //答案在右子树
    }
}
```
