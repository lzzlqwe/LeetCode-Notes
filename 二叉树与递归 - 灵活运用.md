# 代表性题目

## [1.相同的树](https://leetcode.cn/problems/same-tree/description/)
思路：两个树是否相等 = 根节点是否相等 + 左子树是否相等 + 右子树是否相等。      
代码：
```
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null || q == null)
            return p == q;
        return p.val == q.val && isSameTree(p.left, q.left)
                 && isSameTree(p.right, q.right);
    }
}
```

## [2.对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
思路：两个树是否轴对称 = 根节点是否相等 + 左右子树是否轴对称 + 右左子树是否轴对称。      
代码：
```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return func(root.left, root.right);
    }

    public boolean func(TreeNode p, TreeNode q) //判断两棵树是否镜像对称
    {
        if(p == null || q == null)
            return p == q;
        return p.val == q.val && func(p.left, q.right) && func(p.right, q.left);
    }
}
```

## [3.平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)
思路：求树的深度，如果树是不平衡的，就返回-1。       
代码：
```
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) != -1;
    }

    public int height(TreeNode node)
    {
        if(node == null)
            return 0;
        int lefth = height(node.left);
        int righth = height(node.right);
        if(lefth == -1 || righth == -1 || Math.abs(lefth - righth) > 1)
            return -1;
        else
            return Math.max(lefth, righth) + 1;
    }
}
```

## [4.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
思路：答案为每一层的最右节点，所以dfs优先递归右子树，如果当前节点深度大于答案的长度，说明该节点是该层的最右节点，加入答案。其实用bfs层序遍历更直观。        
代码：
```
class Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 1);
        return ans;
    }

    public void dfs(TreeNode node, int depth)
    {
        if(node == null)
            return;
        if(depth > ans.size())
            ans.add(node.val);
        dfs(node.right, depth+1);
        dfs(node.left, depth+1);
    }
}
```
